## 04. 함수와 프로토타입 체이닝

자바스크립트에서 함수를 생성하는 방법은 3가지가 있다. 각각의 방식에 따라 함수 동작이 미묘하게 차이가 난다.

- 함수 선언문(function statement)
- 함수 표현식(function expression)
- Function () 생성자 함수

자바스크립트에서는 함수 리터럴을 이용해 함수를 생성할 수 있다. 함수 선언문이나 함수 표현식 방법 모두 이런 함수 리터럴 방식으로 함수를 생성한다.

```javascript
// 함수 리터럴을 통한 add() 함수 정의
function add(x, y) {
    return x + y;
}
```

__함수 선언문__ 방식은 함수 리터럴 형태와 같다. 하지만 반드시 함수명이 정의되어 있어야 한다.

```javascript
// add() 함수 선언문
function add(x, y) {
    return x + y;
}
```

__함수 표현식__ 은 함수 리터럴로 하나의 함수를 만들고, 여기서 생성된 함수를 변수에 할당하여 함수를 생성하는 방식이다.

```javascript
// add() 함수 표현식
var add = function (x, y) {
    return x + y;
}

var plus = add;

console.log(add(3, 4)); // 7
console.log(plus(3, 4)); // 7
```

add 변수는 함수 리터럴로 생성한 함수를 참조하는 변수이지, 함수 선언문 처럼 함수 이름이 아니다. 함수 표현식 방법에서는 함수 이름이 선택 사항이며, 보통 사용하지 않는다.

위의 예제처럼 익명 함수를 이용한 함수 표현식 방법을 __익명 함수 표현식__ 이라고 부른다. 함수 이름이 포함된 함수 표현식을 __기명 함수 표현식__ 이라 한다.

```javascript
var add = function sum(x ,y) {
    return x + y;
};

console.log(add(3, 4)); // 7
console.log(sum(3, 4)); // Uncaught ReferenceError: sum is not defined 에러 발생
```

함수 표현식에 사용된 함수 이름은 함수 내부에서 해당 함수를 재귀적으로 호출하거나, 디버거 등에서 함수를 구분할 때 사용된다. 함수 외부에서 해당 함수를 호출할 때는 에러가 발생한다.

함수 선언문 형식으로 정의된 함수는 자바스크립트 엔진에 의해 함수 표현식 형태로 변경되기 때문에 외부에서 호출이 가능하다.

```javascript
// 함수 선언문으로 정의된 함수
function add(x, y) {
    return x + y;
}


// 자바스크립트 엔진에 의해 표현식 형태로 변형된 결과
var add = function add(x, y) {
    return x + y;
};
```

> 일반적으로 자바스크립트 코드를 작성할 때 함수 선언문 방식으로 선언된 함수의 경우는 함수 끝에 세미콜론(;)을 붙이지 않지만, 함수 표현식 방식의 경우 세미콜론(;)을 붙이는 것을 권장한다.

자바스크립트 함수도 __Function()__ 이라는 기본 내장 생성자 함수로부터 생성된 객체라고 볼 수 있다. 함수 선언문이나 함수 표현식 방식도 내부적으로는 Function() 생성자 함수로 함수가 생성된다고 볼 수 있다.

```javascript
new Function (arg1, arg2, ... argN, functionBody)

// arg1, arg2, ... argN - 함수의 매개변수
// functionBody - 함수가 호출될 때 실행될 코드를 포함한 문자열
```

```javascript
var add = new Function('x', 'y', 'return x + y');
console.log(add(3, 4)); // 7
```

위에서 살펴본 함수를 생성하는 3가지 방식(함수 선언문, 함수 표현식, 생성자 함수) 사이에는 약간씩 차이가 있다. 그중의 하나가 __함수 호이스팅(Function Hoisting)__ 이다.

자바스크립트 Guru로 알려진 더글라스 크락포드는 함수 생성에 있어서 그의 저서 *더글라스 크락포드의 자바스크립트 핵심가이드* 에서 함수 표현식만을 사용할 것을 권하고 있따. 그 이유 중 하나가 바로 함수 호이스팅 때문이다.

```javascript
add(2, 3); //5

// 함수 선언문 형태로 add() 함수 정의
function add(x, y) {
    return x + y;
}

add(3, 4); //7
```

위의 예제처럼 함수가 자신이 위치한 코드에 상관없이 __함수 선언문 형태로 정의한 함수의 유효 범위는 코드의 맨 처음부터 시작한다.__ 이것을 __함수 호이스팅__ 이라고 부른다.

더글라스 크락포드는 이러한 함수 호이스팅은 코드의 구조를 엉성하게 만들 수도 있다고 지적하며, 함수 표현식 사용을 권장하고 있다.

```javascript
add(2, 3); // uncaught type error

// 함수 표현식 형태로 add() 함수 정의
var add = function(x, y) {
    return x + y;
}

add(3, 4); // 7
```

위의 예제는 함수 표현식 형태로 정의되어 있어 __호이스팅이 일어나지 않는다.__ 이러한 함수 호이스팅이 발생하는 원인은 자바스크립트의 __변수 생성(Instantiation)__ 과 __초기화(Initialization)__ 의 작업이 분리돼서 진행되기 때문이다. (chap5에서 다룸)

자바스크립트에서 함수도 객체이므로 일반 객체처럼 취급될 수 있다. 또한 함수는 다음과 같은 동작이 가능하다.

- 리터럴에 의해 생성
- 변수나 배열의 요소, 객체의 프로퍼티 등에 할당 가능
- 함수의 인자로 전달 가능
- 함수의 리턴값으로 리턴 가능
- 동적으로 프로퍼티를 생성 및 할당 가능

이와 같은 특징이 있으므로 자바스크립트에서는 함수를 __일급 객체__ 라고 부르며, 이런 특성으로 함수형 프로그래밍이 가능하다.

```javascript
// 함수 선언 방식응로 add() 함수 정의
function add(x, y) {
    return x + y;
}

add.result = add(2, 3);
add.status = 'OK';

console.log(add.result); // 5
console.log(add.status); // 'OK'
```

위의 예제는 함수에 동적으로 프로퍼티를 생성할 수 있다는 것을 보여준다. 함수 코드는 함수 객체의 __[[Code]] 내부 프로퍼티__ 에 자동으로 저장된다(ECMAScript 명세).
